<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Security | Jimmy's blog]]></title>
  <link href="http://jianiau.github.io/blog/categories/security/atom.xml" rel="self"/>
  <link href="http://jianiau.github.io/"/>
  <updated>2016-03-21T00:03:34+08:00</updated>
  <id>http://jianiau.github.io/</id>
  <author>
    <name><![CDATA[Jimmy Huang]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[DOCSIS BPI 解密 - 解開 PDU]]></title>
    <link href="http://jianiau.github.io/blog/2016/03/20/docsis-bpi-decrypt-packet-pdu/"/>
    <updated>2016-03-20T19:56:38+08:00</updated>
    <id>http://jianiau.github.io/blog/2016/03/20/docsis-bpi-decrypt-packet-pdu</id>
    <content type="html"><![CDATA[<h2 id="section">簡介</h2>
<p>在<a href="http://blog.jianiau.net/blog/2016/03/19/docsis-bpi-decrypt-get-tek/">DOCSIS BPI 解密 - 取得 TEK</a>中已經把 TEK 解出來，接下來只要使用對的的演算法就能解開加密的封包了。
<!-- more -->
延續之前的範例，用 Key Reply 裡的參數來解密</p>

<h2 id="section-1">加解密參數</h2>
<p>Key Reply 的內容為
<img src="http://blog.jianiau.net/images/blog/key_reply.png">
其中用來加解密的 key 為 TEK 以及 IV，此範例中 TEK=0xe6600fd8852ef5ab IV=0x810e528e1c5fda1a
其他參數用來指示這組 key 能用多久以及提供一個序號，在 DOCSIS 封包的 header 裡會帶有這個序號標示使用的是那一組 key。
<img src="http://blog.jianiau.net/images/blog/pdu_eh_privacy.png">
真正被加密的部份只有 Packet PDU (Layer 2 Ethernet frame) 中 DA (destination MAC) SA (source MAC) 之後的內容。以下只探討 Packet PDU 的部份。</p>

<h2 id="section-2">加密演算法</h2>
<p>加密 PDU 使用的是 <a href="https://zh.wikipedia.org/wiki/%E8%B3%87%E6%96%99%E5%8A%A0%E5%AF%86%E6%A8%99%E6%BA%96">DES</a>，這是一種 <a href="https://zh.wikipedia.org/w/index.php?title=%E5%88%86%E7%BB%84%E5%AF%86%E7%A0%81&amp;redirect=no">Block cipher</a>
有多種<a href="https://zh.wikipedia.org/wiki/%E5%9D%97%E5%AF%86%E7%A0%81%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%A8%A1%E5%BC%8F">工作模式</a>，DES 使用的 block size 為 8 bytes，DOCSIS BPI 用了 CBC 和 CFB 這兩種工作模式。
由於封包長度不固定，但是使用這種加密方式輸入必須要是 8 bytes 的整數倍，所以會用 2 種工作模式來處理。</p>

<h2 id="cbc-only">CBC only</h2>
<p>若要加密的內容正好是 8 bytes 的整數倍，直接使用 DES-CBC 加密
若輸入為</p>

<table>
  <tbody>
    <tr>
      <td>DA</td>
      <td>01 02 03 04 05 06</td>
    </tr>
    <tr>
      <td>SA</td>
      <td>f1 f2 f3 f4 f5 f6</td>
    </tr>
    <tr>
      <td>Type/Len</td>
      <td>00 01</td>
    </tr>
    <tr>
      <td>User Data</td>
      <td>02 03 04 05 06 07 08 09 0a 0b</td>
    </tr>
    <tr>
      <td>CRC</td>
      <td>88 41 65 06</td>
    </tr>
  </tbody>
</table>

<p><br />則加密後會變成</p>

<table>
  <tbody>
    <tr>
      <td>DA</td>
      <td>01 02 03 04 05 06</td>
    </tr>
    <tr>
      <td>SA</td>
      <td>f1 f2 f3 f4 f5 f6</td>
    </tr>
    <tr>
      <td>Type/Len</td>
      <td>0d da</td>
    </tr>
    <tr>
      <td>User Data</td>
      <td>5a cb d0 5e 55 67 9f 04 d1 b6</td>
    </tr>
    <tr>
      <td>CRC</td>
      <td>41 3d 4e ed</td>
    </tr>
  </tbody>
</table>

<p><br />使用 tcl 解密
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='tcl'><span class='line'><span class="nb">package</span> require tclDES
</span><span class='line'><span class="k">set</span> iv  <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mi">810</span>e528e1c5fda1a<span class="k">]</span>
</span><span class='line'><span class="k">set</span> keyset <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>keyset create <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> e6600fd8852ef5ab<span class="k">]]</span>
</span><span class='line'><span class="k">set</span> cipher <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mi">0</span>dda5acbd05e55679f04d1b6413d4eed <span class="k">]</span>
</span><span class='line'><span class="k">set</span> plain <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>decrypt <span class="nv">$keyset</span> <span class="nv">$cipher</span> cbc iv<span class="k">]</span>
</span><span class='line'><span class="nb">binary</span> scan <span class="nv">$plain</span> H<span class="o">*</span> plain
</span><span class='line'><span class="nb">puts</span> plaintext<span class="err">=</span><span class="nv">$plain</span>
</span></code></pre></td></tr></table></div></figure>
plaintext=000102030405060708090a0b88416506</p>

<h2 id="cbc--cfb">CBC + CFB</h2>
<p>若要加密的內容大於 8 bytes 但不是 8 bytes 的整數倍要分成兩段加密，第一部份是 8 bytes 的整數倍使用 CBC，剩餘的部份使用 CFB。
若輸入為</p>

<table>
  <tbody>
    <tr>
      <td>DA</td>
      <td>01 02 03 04 05 06</td>
    </tr>
    <tr>
      <td>SA</td>
      <td>f1 f2 f3 f4 f5 f6</td>
    </tr>
    <tr>
      <td>Type/Len</td>
      <td>00 01</td>
    </tr>
    <tr>
      <td>User Data</td>
      <td>02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e</td>
    </tr>
    <tr>
      <td>CRC</td>
      <td>91 d2 d1 9f</td>
    </tr>
  </tbody>
</table>

<p><br />則加密後會變成</p>

<table>
  <tbody>
    <tr>
      <td>DA</td>
      <td>01 02 03 04 05 06</td>
    </tr>
    <tr>
      <td>SA</td>
      <td>f1 f2 f3 f4 f5 f6</td>
    </tr>
    <tr>
      <td>Type/Len</td>
      <td>0d 0a</td>
    </tr>
    <tr>
      <td>User Data</td>
      <td>5a cb d0 5e 55 67 51 47 46 86 8a 71 e5</td>
    </tr>
    <tr>
      <td>CRC</td>
      <td>77 ef ac 88</td>
    </tr>
  </tbody>
</table>

<p>首先是 CBC 的部份，和之前作法相同，要加密的資料是 0x0001…0e91 這 16 bytes，剩下的 3 bytes 0xd2d19f 要特別處理，因為 DES 要輸入 8 bytes 整數倍，所以先補 0x00 補到 8 bytes，
接著再用 DES-CFB 加密 (此時使用的 key 不變，IV 換成 CBC 密文區塊中的最後 8 bytes)，加密完後載取出前 3 bytes 即可，透過照種方式就能讓加密前後的資料長度維持不變。</p>

<p>同樣使用 tcl 解密
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='tcl'><span class='line'><span class="nb">package</span> require tclDES
</span><span class='line'><span class="c"># CBC 區塊</span>
</span><span class='line'><span class="k">set</span> iv  <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mi">810</span>e528e1c5fda1a<span class="k">]</span>
</span><span class='line'><span class="k">set</span> keyset <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>keyset create <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> e6600fd8852ef5ab<span class="k">]]</span>
</span><span class='line'><span class="k">set</span> cipher <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mi">0</span>dda5acbd05e5567514746868a71e577<span class="k">]</span>
</span><span class='line'><span class="k">set</span> plain <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>decrypt <span class="nv">$keyset</span> <span class="nv">$cipher</span> cbc iv<span class="k">]</span>
</span><span class='line'><span class="nb">binary</span> scan <span class="nv">$plain</span> H<span class="o">*</span> plain
</span><span class='line'><span class="nb">puts</span> plaintext<span class="err">=</span><span class="nv">$plain</span><span class="o">&lt;/</span>p<span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nv">h1</span> id<span class="err">=</span><span class="s2">&quot;cfb-&quot;</span><span class="o">&gt;</span>CFB <span class="err">區塊</span><span class="o">&lt;/</span>h1<span class="o">&gt;</span>
</span><span class='line'><span class="o">&lt;</span><span class="nv">p</span><span class="o">&gt;</span>set iv  <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mi">514746868</span>a71e577<span class="k">]</span> <span class="k">;</span> <span class="c"># IV 要換掉</span>
</span><span class='line'><span class="k">set</span> keyset <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>keyset create <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> e6600fd8852ef5ab<span class="k">]]</span>
</span><span class='line'><span class="c"># CFB 工作模式的特性,解密時後面亂填不影響真正要的部份,這邊補0x00</span>
</span><span class='line'><span class="k">set</span> cipher <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> efac880000000000<span class="k">]</span>
</span><span class='line'><span class="k">set</span> plain <span class="k">[</span><span class="nb">string</span> range <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>decrypt <span class="nv">$keyset</span> <span class="nv">$cipher</span> cfb iv<span class="k">]</span> <span class="mi">0</span> <span class="mi">2</span><span class="k">]</span>
</span><span class='line'><span class="nb">binary</span> scan <span class="nv">$plain</span> H<span class="o">*</span> plain
</span><span class='line'><span class="nb">puts</span> plaintext<span class="err">=</span><span class="nv">$plain</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>plaintext=000102030405060708090a0b0c0d0e91 <br />
plaintext=d2d19f</p>

<h2 id="cfb-only">CFB only</h2>
<p>若要加密的內容小於 8 bytes，就使用 DES-CFB，key 和 IV 使用 key reply 取得的資訊，
若輸入為</p>

<table>
  <tbody>
    <tr>
      <td>DA</td>
      <td>01 02 03 04 05 06</td>
    </tr>
    <tr>
      <td>SA</td>
      <td>f1 f2 f3 f4 f5 f6</td>
    </tr>
    <tr>
      <td>Type/Len</td>
      <td>00 01</td>
    </tr>
    <tr>
      <td>User Data</td>
      <td>02</td>
    </tr>
    <tr>
      <td>CRC</td>
      <td>88 ee 59 7e</td>
    </tr>
  </tbody>
</table>

<p><br />加密後會變成</p>

<table>
  <tbody>
    <tr>
      <td>DA</td>
      <td>01 02 03 04 05 06</td>
    </tr>
    <tr>
      <td>SA</td>
      <td>f1 f2 f3 f4 f5 f6</td>
    </tr>
    <tr>
      <td>Type/Len</td>
      <td>17 86</td>
    </tr>
    <tr>
      <td>User Data</td>
      <td>a8</td>
    </tr>
    <tr>
      <td>CRC</td>
      <td>03 a0 85 75</td>
    </tr>
  </tbody>
</table>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='tcl'><span class='line'><span class="nb">package</span> require tclDES
</span><span class='line'><span class="k">set</span> iv  <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mi">810</span>e528e1c5fda1a<span class="k">]</span>
</span><span class='line'><span class="k">set</span> keyset <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>keyset create <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> e6600fd8852ef5ab<span class="k">]]</span>
</span><span class='line'><span class="c"># 資料只有 7 bytes, 補一個 00</span>
</span><span class='line'><span class="k">set</span> cipher <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mi">1786</span>a803a0857500<span class="k">]</span>
</span><span class='line'><span class="k">set</span> plain  <span class="k">[</span><span class="nb">string</span> range <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>decrypt <span class="nv">$keyset</span> <span class="nv">$cipher</span> cfb iv<span class="k">]</span> <span class="mi">0</span> <span class="mi">6</span><span class="k">]</span>
</span><span class='line'><span class="nb">binary</span> scan <span class="nv">$plain</span> H<span class="o">*</span> plain
</span><span class='line'><span class="nb">puts</span> plaintext<span class="err">=</span><span class="nv">$plain</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>plaintext=00010288ee597e</p>

<h2 id="crc">CRC</h2>
<p>解密完後可以算一下 CRC 來驗證有沒有算錯，CRC 計算範圍是 Ethernet frame 扣除 CRC 4 bytes，以最後這個 CFB only 的範例來看</p>

<p>inputt = 0x010203040506f1f2f3f4f5f6000102</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='tcl'><span class='line'><span class="nb">package</span> require crc32
</span><span class='line'><span class="k">set</span> crc <span class="k">[</span><span class="nv">crc</span><span class="o">::</span>crc32 <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mo">010203040506</span>f1f2f3f4f5f6000102<span class="k">]]</span>
</span><span class='line'><span class="nb">binary</span> scan <span class="k">[</span><span class="nb">binary</span> format i <span class="nv">$crc</span><span class="k">]</span> H<span class="o">*</span> CRC
</span><span class='line'><span class="nb">puts</span> CRC<span class="err">=</span><span class="nv">$CRC</span>
</span></code></pre></td></tr></table></div></figure>
CRC=88ee597e</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DOCSIS BPI 解密 - 取得 TEK]]></title>
    <link href="http://jianiau.github.io/blog/2016/03/19/docsis-bpi-decrypt-get-tek/"/>
    <updated>2016-03-19T23:53:55+08:00</updated>
    <id>http://jianiau.github.io/blog/2016/03/19/docsis-bpi-decrypt-get-tek</id>
    <content type="html"><![CDATA[<h2 id="section">簡介</h2>

<p>DOCSIS 1.0 BPI 加密使用的是 DES，為了能解開封包內容必須先取得 TEK (raffic Encryption Key)。取得 TEK 是透過 BPKM (Baseline Privacy Key Management) Protocol。
BPKM 的過程中 CMTS 會使用 RSA 加密 Auth Key，CM 解開 Auth Key 後算出 KEK (Key Encryption Key)，接著再用 KEK 解開 TEK，之後就能用 TEK 進行加密。
<!-- more --></p>

<p>以下範例出自 DOCSIS 1.0 Baseline Privacy Interface Specification，擷取到 DOCSIS 封包後只要擁有 CM 的 private key，透過一些操作就能解開封包內容</p>

<p>此範例所用的 private key 如下</p>

<p><figure class='code'><figcaption><span>cm_private_key </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>—–BEGIN PRIVATE KEY—–
</span><span class='line'>MIIB5gIBADANBgkqhkiG9w0BAQEFAASCAdAwggHMAgEAAmEA0/SEuCPOcDXnqzIw
</span><span class='line'>QxP//xsmwvh/5uUPIprtgBPYHZW0MIfwtatQ3rHYgrJCqWcz2eXCsSoNQliUYwsR
</span><span class='line'>DqBVlrHPwH8Ul0a8RBNLXkreRs7ryLY1imabM8IjdfXIaXllAgMBAAECYQCTQM6w
</span><span class='line'>C5hRlvGzm3OyNoPk3R0p2XEqnbrNJOuZzq+XpjkAeoE+BZ5yiQZNjsEHZj146Wd9
</span><span class='line'>q+Xo80xwTlz++xUljzdU7doBjsje/mD1ob3obE/FcWGmb6dVySnYyovxxYUCMQDx
</span><span class='line'>IR7RSf+VM+Vg3kyurvZ1EYuW1UVFlu6Ioz3ZoRdmQq51e8YYCg14ObVemRbGLdsC
</span><span class='line'>MQDhBs3QCMkVCRSTioyl14S4VhVCOLfnjonL1lafWXYgEH9ebuHD6jFBkOCOJEde
</span><span class='line'>ub8CMQC/v+rV29aXO9Gomp64OwJaTj2HEMopcMD3f3jr26LT+yro2ijJbRURCjMk
</span><span class='line'>qvDlYAkCMDIClhkG6tGO/BCyOQHefPOOxhi6jDydFAjGMOgnNLZ5lCUDlY857Ap7
</span><span class='line'>TTyp2Wa29wIxAJV1icfFAoGlWRmP+soKv7iNG8m5efvRTx+zyjIw19FY7QRkxTWy
</span><span class='line'>2yGB77D9b/FjJw==
</span><span class='line'>—–END PRIVATE KEY—–</span></code></pre></td></tr></table></div></figure></p>

<p>DOCSIS 1.0 時沒有使用 certificate 來驗證 CM 的身份，只用了 RSA 加密，所以只要修改 CM mac address，就能冒充其他 CM， DOCSIS 1.1 BPI+ 就加上 certificate，這樣就無法輕易假冒其他 CM 了。</p>

<h2 id="bpkm-protocol">BPKM Protocol</h2>

<p>順利的話 BPKM 要 4 個步驟：Auth Request， Auth Reply, Key Request, 以及 Key Reply。</p>

<h3 id="auth-request">Auth Request</h3>

<p>首先，當 CM 註冊完且需要開啟 BPI 時會送出 Auth Request，內容包含一些基本資訊以及最重要的 RSA Public Key</p>

<p><img src="http://blog.jianiau.net/images/blog/auth_req.png"></p>

<h3 id="auth-reply">Auth Reply</h3>

<p>CMTS 收到 Auth Request 後會產生一把 Auth Key，把 Auth Key 利用 CM 的 RSA Public Key 加密後透過 Auth Reply 傳給 CM。</p>

<p><img src="http://blog.jianiau.net/images/blog/auth_reply.png"></p>

<p>Auth Key 中的 0x07 是 Identifier， 0x0060 是長度 (96 bytes)，真正的資料是 0xce7f8efe … 3ac4c480</p>
<p class="info">
DOCSIS 1.0 用的 RSA key 比較短，這個範例中用的是 768 bits，所以加密後的 Auth Key 是 96 bytes。
</p>

<p>可以利用 OpenSSL 把這段資料解密</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>openssl rsautl -in auth_key -inkey cm_private_key -decrypt -hexdump
</span><span class='line'>0000 - 3b d5 50 60 bd a2 57 c0-                          ;.P`..W.</span></code></pre></td></tr></table></div></figure></p>

<p>解出來 auth key 是 0x3bd55060bda257c0，利用 auth key 再算出之後步驟要用到的 3 個值，Key Encryption Key, upstream Message Authentication Key, 
downstream Message Authentication Key。</p>

<p>這 3 把 key 算法都是透過 sha1</p>

<ol>
  <li>
    <p>Key Encryption Key <br />
 在 auth key 前補上 64 個 0x53 後計算 sha1，再取前 8 bytes 當作 KEK</p>
  </li>
  <li>
    <p>upstream Message Authentication Key <br />
 在 auth key 前補上 64 個 0x5c 後計算 sha1</p>
  </li>
  <li>
    <p>downstream Message Authentication Key <br />
 在 auth key 前補上 64 個 0x3a 後計算 sha1</p>
  </li>
</ol>

<p>利用 tcl 計算
<figure class='code'><figcaption><span>calckek.tcl </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='tcl'><span class='line'><span class="nb">package</span> require sha1
</span><span class='line'><span class="k">set</span> auth_key <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mi">3</span>bd55060bda257c0<span class="k">]</span>
</span><span class='line'><span class="k">set</span> KEK <span class="k">[</span><span class="nb">string</span> range <span class="k">[</span><span class="nv">sha1</span><span class="o">::</span>sha1 <span class="o">-</span>hex <span class="k">[</span><span class="nb">string</span> repeat <span class="err">\</span>x53 <span class="mi">64</span><span class="k">]</span><span class="nv">$auth_key</span><span class="k">]</span> <span class="mi">0</span> <span class="mi">15</span><span class="k">]</span>
</span><span class='line'><span class="k">set</span> UAK <span class="k">[</span><span class="nv">sha1</span><span class="o">::</span>sha1 <span class="o">-</span>hex <span class="k">[</span><span class="nb">string</span> repeat <span class="err">\</span>x5c <span class="mi">64</span><span class="k">]</span><span class="nv">$auth_key</span><span class="k">]</span>
</span><span class='line'><span class="k">set</span> DAK <span class="k">[</span><span class="nv">sha1</span><span class="o">::</span>sha1 <span class="o">-</span>hex <span class="k">[</span><span class="nb">string</span> repeat <span class="err">\</span>x3a <span class="mi">64</span><span class="k">]</span><span class="nv">$auth_key</span><span class="k">]</span><span class="o">&lt;/</span>p<span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="nv">p</span><span class="o">&gt;</span>puts <span class="err">“</span>Key Encryption Key: <span class="nv">$KEK</span><span class="err">”</span>
</span><span class='line'><span class="nb">puts</span> <span class="err">“</span>upstream Message Authentication Key: <span class="nv">$UAK</span><span class="err">”</span>
</span><span class='line'><span class="nb">puts</span> <span class="err">“</span>downstream Message Authentication Key: <span class="nv">$DAK</span><span class="err">”</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>結果為
<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Key Encryption Key: 5f59051d9217d983
</span><span class='line'>upstream Message Authentication Key: ebff98cd5cd457bbfd12b565ffaaf689d4982614
</span><span class='line'>downstream Message Authentication Key: 5e4769839eeee4d004a4c12380b05ad18ac92c9c</span></code></pre></td></tr></table></div></figure></p>

<h3 id="key-request">Key Request</h3>

<p>接著 CM 送出 key request，除了一些 CM 的基本資訊外還有在 auth reply 取得的 Key Sequence Number，最後會補上 HMAC digest</p>

<p><img src="http://blog.jianiau.net/images/blog/key_req.png"></p>

<p>這個 HMAC digest 是利用 upstream Message Authentication Key 計算 Key Request 封包，從 Key Request Header 到 SID (0x0773…0c00022260)，使用的演算法是 HMAC-SHA-1</p>

<p class="info">
CMTS 可以透過這個方式驗證送出 key request 的 CM，因為這個 key 是由 auth key 算出來的，而 auth key 是透過 RSA public key加密，只有擁有該 private key 的 CM 能送出正確的封包。
</p>

<h3 id="key-reply">Key Reply</h3>

<p>最後 CMTS 確認完 Key Request 沒問題後就把之後要用的 TEK 利用 KEK 加密後送出，這邊使用的演算法是 DES-ECB</p>

<p><img src="http://blog.jianiau.net/images/blog/key_reply.png"></p>

<p>與 key request 類似， key reply 也有一個 HMAC digest 讓 CM 驗證</p>

<p>使用 OpenSSL 解密</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'><span class="nb">echo</span> -n -e “<span class="se">\x</span>ab<span class="se">\x</span>b9<span class="se">\x</span>d6<span class="se">\x</span>03<span class="se">\x</span>23<span class="se">\x</span>86<span class="se">\x</span>db<span class="se">\x</span>ce” <span class="p">&amp;</span>gt<span class="p">;</span> tek
</span><span class='line'>openssl des-ecb -in tek -d -nopad -K 5f59051d9217d983 <span class="p">|</span> hexdump -C
</span><span class='line'><span class="m">00000000</span>  e6 <span class="m">60</span> 0f d8 <span class="m">85</span> 2e f5 ab                           <span class="p">|</span>.<span class="sb">`</span>……<span class="p">|</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>tcl 有 tclDES 可以用來解密</p>

<p><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='tcl'><span class='line'><span class="nb">package</span> require tclDES
</span><span class='line'><span class="k">set</span> keyset <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>keyset create <span class="k">[</span><span class="nb">binary</span> format H<span class="o">*</span> <span class="mi">5</span>f59051d9217d983<span class="k">]]</span>
</span><span class='line'><span class="k">set</span> tek <span class="k">[</span><span class="o">::</span><span class="nv">des</span><span class="o">::</span>decrypt <span class="nv">$keyset</span> <span class="err">\</span>xab<span class="err">\</span>xb9<span class="err">\</span>xd6<span class="err">\</span>x03<span class="err">\</span>x23<span class="err">\</span>x86<span class="err">\</span>xdb<span class="err">\</span>xce ecb<span class="k">]</span>
</span><span class='line'><span class="nb">binary</span> scan <span class="nv">$tek</span> H<span class="o">*</span> TEK
</span><span class='line'><span class="nb">puts</span> TEK<span class="err">=</span><span class="nv">$TEK</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>最後算出來的值為 0xe6600fd8852ef5ab，取得 TEK 後就能解開加密的封包了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[EuroDOCSIS Certificate]]></title>
    <link href="http://jianiau.github.io/blog/2016/01/03/eurodocsis-certificate/"/>
    <updated>2016-01-03T23:34:51+08:00</updated>
    <id>http://jianiau.github.io/blog/2016/01/03/eurodocsis-certificate</id>
    <content type="html"><![CDATA[<p>EuroDOCSIS 的 BPI+ 規範基本上和 DOCSIS 是一樣的, 只是 certificates 的一些欄位名稱換一下而已</p>

<p>EuroDOCSIS Root Certificate</p>

<pre><code>countryName=BE
organizationName=tComLabs – Euro-DOCSIS
organizationalUnitName=Cable Modems
commonName= Euro-DOCSIS Cable Modem Root CA
</code></pre>

<p>EuroDOCSIS Manufacturer Certificate</p>

<pre><code>countryName=&lt;Country of Manufacturer&gt;
[stateOrProvinceName=&lt;state/province&gt;]
[localityName=&lt;City&gt;]
organizationName=&lt;Company Name&gt;
organizationalUnitName=Euro-DOCSIS
[organizationalUnitName=&lt;Manufacturing Location&gt;]
commonName=&lt;Company Name&gt; Cable Modem Root Certificate Authority
</code></pre>

<p class="info">
比較特別是 oganizationalUnitName 的值也可以是 DOCSIS
</p>

<p>EuroDOCSIS Code Verification Certificate</p>

<pre><code>countryName = &lt;country&gt;
organizationName = &lt;Manufacturer organizationName from CA Certificate&gt;
organizationalUnitName = Euro-DOCSIS
commonName = Code Verification Certificate
</code></pre>

<h2 id="section">參考資料</h2>

<ul>
  <li>EuroDOCSIS.BPI+Req.pdf Rev:7.0</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[DOCSIS Certificate]]></title>
    <link href="http://jianiau.github.io/blog/2016/01/03/docsis-certificate/"/>
    <updated>2016-01-03T01:10:13+08:00</updated>
    <id>http://jianiau.github.io/blog/2016/01/03/docsis-certificate</id>
    <content type="html"><![CDATA[<p>DOCSIS 是從 DOCSIS 1.1 (BPI+) 開始使用 certificate 來驗證 CM 和 CMTS 之間金鑰交換的訊息, 在 DOCSIS 1.0 (BPI), CM 送出 AUTH-REQ 時沒有憑證, 直接丟出 RSA public key, BPI+ 加強了這一階段的驗證, CM 要送出 AUTH-INFO (CA certificate), AUTH-REQ (CM certificate), 讓 CMTS 驗證 CM 來源是否正確</p>

<h2 id="bpi-certificate-">BPI+ Certificate 架構</h2>

<p>BPI+ certificate 共有 3 層</p>

<ul>
  <li>DOCSIS Root CA certificate</li>
  <li>Manufacturer CA (distributed model) or CableLabs Mfg CA (centralized model) certificates</li>
  <li>CM Device certificate</li>
</ul>

<p class="info">
Cablelabs 已經不再簽發 Manufacturer CA certificate, 只剩下 centralized model, 另外 Root 除了簽發 Mfg CA certificate 以外, 也用來簽發 Code Verification Certificate (Legacy-PKI) 和 CableLabs DOCSIS CVC CA Certificate (New-PKI)
</p>

<!-- more -->

<h2 id="certificate-">Certificate 格式</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: left">X.509 v3 Field</th>
      <th style="text-align: left">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: left">tbsCertificate.version</td>
      <td style="text-align: left">Indicates the certificate version. Always set to v3 (value is 2)</td>
    </tr>
    <tr>
      <td style="text-align: left">tbsCertificate.serialNumber</td>
      <td style="text-align: left">Unique integer assigned by the issuing CA to the certificate</td>
    </tr>
    <tr>
      <td style="text-align: left">tbsCertificate.signature</td>
      <td style="text-align: left">OID and optional parameters defining the algorithm used to sign the certificate. This field contains the same algorithm identifier as the signatureAlgorithm field below</td>
    </tr>
    <tr>
      <td style="text-align: left">tbsCertificate.issuer</td>
      <td style="text-align: left">Distinguished Name of the CA that issued the certificate</td>
    </tr>
    <tr>
      <td style="text-align: left">Certificate.validity</td>
      <td style="text-align: left">Defines when the certificate becomes active and when it expires</td>
    </tr>
    <tr>
      <td style="text-align: left">tbsCertificate.subject</td>
      <td style="text-align: left">Distinguished Name identifying the entity whose public key is certified in the subjectPublicKeyInfo field</td>
    </tr>
    <tr>
      <td style="text-align: left">tbsCertificate.subjectPublicKeyInfo</td>
      <td style="text-align: left">Field contains the public key material (public key and parameters) and the identifier of the algorithm with which the key is used</td>
    </tr>
    <tr>
      <td style="text-align: left">tbsCertificate.issuerUniqueID</td>
      <td style="text-align: left">Optional field to allow reuse of issuer names over time</td>
    </tr>
    <tr>
      <td style="text-align: left">tbsCertificate.subjectUnique ID</td>
      <td style="text-align: left">Optional field to allow reuse of subject names over time</td>
    </tr>
    <tr>
      <td style="text-align: left">tbsCertificate.extensions</td>
      <td style="text-align: left">Extension data</td>
    </tr>
    <tr>
      <td style="text-align: left">SignatureAlgorithm</td>
      <td style="text-align: left">OID and optional parameters defining the algorithm used to sign the certificate. This field contains the same algorithm identifier as the signature field in tbsCertificate</td>
    </tr>
    <tr>
      <td style="text-align: left">signatureValue</td>
      <td style="text-align: left">Digital signature computed over the ASN.1 DER-encoded tbsCertificate</td>
    </tr>
  </tbody>
</table>

<p><br /></p>

<dl>
  <dt><strong>signature</strong></dt>
  <dd>
    <p>DOCSIS 3.0 以前的 certificates 用的都是 <a href="http://www.alvestrand.no/objectid/1.2.840.113549.1.1.5.html">sha1WithRSAEncryption</a>, DOCSIS 3.1 開始改成 <a href="http://www.alvestrand.no/objectid/1.2.840.113549.1.1.11.html">sha256WithRSAEncryption</a></p>
  </dd>
  <dt><strong>validity</strong></dt>
  <dd>
    <p>DOCSIS 3.0 以前使用 ASN.1 UTCTime 編碼, 時間範圍是 1950~2049, 3.1 之後時間會超過 2050, 超過的部份改用 GeneralizedTime 編碼</p>
  </dd>
  <dt><strong>issuer, subject</strong></dt>
  <dd>
    <p>這裡的文字編碼一律先採用 PrintableString set, 若出現其他字元 DOCSIS 3.0 用 T.61/TeletexString, DOCSIS 3.1 用 UTF8String</p>
  </dd>
</dl>

<p>Legacy-PKI</p>

<pre><code>DOCSIS Root Certificate  
  countryName=US
  organizationName=Data Over Cable Service Interface Specifications
  organizationalUnitName=Cable Modems
  commonName=DOCSIS Cable Modem Root Certificate Authority
 
CableLabs Mfg CA Certificate
  countryName=US
  organizationName=CableLabs, Inc.
  organizationalUnitName=DOCSIS
  organizationalUnitName=D CA00001
  commonName=CableLabs, Inc. Cable Modem Root Certificate

Manufacturer CA Certificate
  countryName=&lt;Country of Manufacturer&gt;
  [stateOrProvinceName=&lt;state/province&gt;]
  [localityName=&lt;City&gt;]
  organizationName=&lt;Company Name&gt;
  organizationalUnitName=DOCSIS
  [organizationalUnitName=&lt;Manufacturing Location&gt;]
  commonName=&lt;Company Name&gt; [&lt;Serial Identifier&gt;] Cable Modem Root Certificate Authority [&lt;SerialIdentifier&gt;]

CM Device Certificate
  countryName=&lt;Country of Manufacturer&gt;
  organizationName=&lt;Company Name&gt;
  organizationalUnitName=&lt;manufacturing location&gt;
  [commonName=&lt;Serial Number&gt;]
  commonName=&lt;MAC Address&gt;

Code Verification Certificate
  countryName＝&lt;country of subject company&gt;
  organizationName=&lt;subject code-signing agent&gt;
  organizationalUnitName=DOCSIS
  commonName=Code Verification Certificate
</code></pre>

<p>用 <code>[]</code> 標示的欄位可以省略, 用<code>&lt;&gt;</code> 標示的欄位要填入相對應的值, countryName 是 2 碼的 <a href="http://www.chemie.fu-berlin.de/diverse/doc/ISO_3166.html">country code</a>, CM MAC 格式範例為 00:55:66:11:22:33</p>

<p class="info">
DOCSIS 3.0 之後的 CM certificate 已經不再使用 commonName=Serial Number
</p>

<p>New-PKI</p>

<pre><code>CableLabs Root CA Certificate
  c=US
  o=CableLabs
  ou=Root CA01
  cn=CableLabs Root Certification Authority

CableLabs Device CACertificate
  c=US
  o=CableLabs
  ou=Device CA01
  cn=CableLabs Device Certification Authority

CM Device Certificate
  c=&lt;Country of Manufacturer&gt;
  o=&lt;Company Name&gt;
  ou=&lt;Manufacturing Location&gt;
  cn=&lt;MAC Address&gt;

CableLabs DOCSIS CVC CA Certificate
  c=US
  o=CableLabs
  ou=CVC CA01
  cn=CableLabs CVC Certification Authority

Code Verification Certificate
  c=&lt;Country of Manufacturer&gt;
  o=&lt;Company Name&gt;
  cn=Code Verification Certificate
</code></pre>

<p class="info">
DOCSIS 3.1 只有 Centralized Model, 沒有 Manufacturer CA certificate 了, CVC 的 chain 則是多了一層 CableLabs DOCSIS CVC CA
</p>

<dl>
  <dt><strong>subjectPublicKeyInfo</strong></dt>
  <dd>
    <p>所有的 DOCSIS certificate 用的都是 <a href="http://www.alvestrand.no/objectid/1.2.840.113549.1.1.1.html">rsaEncryption</a>, 差別在於 key 的長度不同</p>
  </dd>
  <dt><strong>issuerUniqueID,subjectUniqueID</strong></dt>
  <dd>
    <p>所有的 DOCSIS certificates 都沒用到這兩個欄位</p>
  </dd>
</dl>

<p><strong>extensions</strong></p>

<p>以下只列出必須有的 extension</p>

<p>Legacy-PKI</p>

<pre><code>DOCSIS Root CA Certificate
  X509v3 extensions:
      X509v3 Basic Constraints: critical
          CA:TRUE, pathlen:1
      X509v3 Key Usage: critical
          Certificate Sign, CRL Sign

CableLabs Mfg CA Certificate
   X509v3 extensions:
       X509v3 Basic Constraints: critical
           CA:TRUE, pathlen:0
       X509v3 Key Usage: critical
           Certificate Sign, CRL Sign

Manufacturer CA Certificates
  X509v3 extensions:
      X509v3 Basic Constraints: critical
          CA:TRUE, pathlen:0
      X509v3 Key Usage: critical
          Certificate Sign, CRL Sign

Code Verification Certificate
  X509v3 extensions:
      X509v3 Extended Key Usage: critical
          Code Signing
</code></pre>

<p class="info">
Manufacturer CA Certificates 也可以沒有這些 extensions
</p>

<p>New-PKI</p>

<pre><code>CableLabs Root CA Certificate
  X509v3 extensions:
      X509v3 Basic Constraints: critical
          CA:TRUE
      X509v3 Key Usage: critical
          Certificate Sign, CRL Sign
      X509v3 Subject Key Identifier:
          Calculated per Method 1

CableLabs Device CACertificate
  X509v3 extensions:
      X509v3 Key Usage: critical
          Certificate Sign, CRL Sign
      X509v3 Basic Constraints: critical
          CA:TRUE, pathlen:0
      X509v3 Subject Key Identifier: 
          Calculated per Method 1
      X509v3 Authority Key Identifier:
          Calculated per Method 1

CM Device Certificate
  X509v3 extensions:
      X509v3 Key Usage: critical
        Digital Signature, Key Encipherment
      X509v3 Authority Key Identifier:
        Calculated per Method 1

CableLabs DOCSIS CVC CA Certificate
  X509v3 extensions:
      X509v3 Key Usage: critical
          Certificate Sign, CRL Sign
      X509v3 Basic Constraints: critical
          CA:TRUE, pathlen:0
      X509v3 Subject Key Identifier:
          Calculated per Method 1 
      X509v3 Authority Key Identifier: 
          Calculated per Method 1

Code Verification Certificate
  X509v3 extensions:
      X509v3 Extended Key Usage: critical
          Code Signing
      X509v3 Authority Key Identifier:
        Calculated per Method 1
</code></pre>

<p class="info">
Authority, Subject Key Identifier 計算方法 <a href="https://tools.ietf.org/html/rfc5280#section-4.2.1.2">RFC5280</a>
</p>

<h2 id="section">參考資料</h2>
<ul>
  <li>CM-SP-BPI+-C01-081104</li>
  <li>CM-SP-SECv3.0-I15-130808</li>
  <li>CM-SP-SECv3.1-I05-151210</li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Generate DOCSIS CVC]]></title>
    <link href="http://jianiau.github.io/blog/2015/12/30/generate-docsis-cvc/"/>
    <updated>2015-12-30T22:18:09+08:00</updated>
    <id>http://jianiau.github.io/blog/2015/12/30/generate-docsis-cvc</id>
    <content type="html"><![CDATA[<p>Code Verification Certificate (CVC) 是 cable modem 作 secure software download (SSD) 時提供給 CM 驗證 image 用的憑證, 
當 manufacturer 要出新的 software 時, 會用 private key 簽名, 並把含有相對應 public key 的 certificate (也就是 CVC) 丟給 CM 驗證, CM 先檢查 CVC, 確認 CVC 正確後就能用 CVC 裡面的 public key 檢查 software 的簽名是否正確, 利用這種方式來驗證 software 的可靠性與正確性</p>

<p>通常, 這個 private key 都會放在一個需要重重關卡才能進入的地方, 所以要測試 CM SSD 功能時會用 Test CVC, 製作 Test CVC 的步驟很簡單, 只要裝好 <a href="https://www.openssl.org/community/binaries.html">OpenSSL</a> 就可以開始製作, CableLabs 有詳細的步驟說明</p>

<!-- more -->

<p>到 <a href="http://cablelabs.com/resources/digital-certificate-issuance-service/">Cablelabs</a> 下載 Test Certificates</p>

<h2 id="legacy-pki-docsis-30-">Legacy PKI (DOCSIS 3.0 以前的版本)</h2>

<p><strong>1. 製作 csr_config.txt</strong></p>

<p><figure class='code'><figcaption><span>csr_config.txt </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="k">[ req ]</span>
</span><span class='line'><span class="na">default_keyfile</span> <span class="o">=</span> <span class="s">TEST_DOCSIS_MFR_CVC_PRIVATEKEY.pem</span>
</span><span class='line'><span class="na">default_md</span> <span class="o">=</span> <span class="s">sha1</span>
</span><span class='line'><span class="na">prompt</span> <span class="o">=</span> <span class="s">no</span>
</span><span class='line'><span class="na">distinguished_name</span> <span class="o">=</span> <span class="s">req_DN&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="na">&lt;h1 id</span><span class="o">=</span><span class="s">&quot;certificate-distinguished-name&quot;&gt;Certificate Distinguished Name&lt;/h1&gt;</span>
</span><span class='line'><span class="err">&lt;p&gt;</span><span class="k">[req_DN]</span>
</span><span class='line'><span class="na">C</span> <span class="o">=</span> <span class="s">TW</span>
</span><span class='line'><span class="na">O</span> <span class="o">=</span>  <span class="s">Jimmy Test</span>
</span><span class='line'><span class="na">OU</span> <span class="o">=</span> <span class="s">DOCSIS</span>
</span><span class='line'><span class="na">CN</span> <span class="o">=</span> <span class="s">TEST Code Verification Certificate</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>O 的值要和 CM 的 manufacturer’s organizationName 一致</p>

<p><strong>2. 用以下指令產生 CSR 和 private key</strong></p>

<p><figure class='code'><figcaption><span>bash </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>openssl req -newkey rsa:2048 -config csr_config.txt -out csr.pem -nodes
</span></code></pre></td></tr></table></div></figure></p>

<p>如果是要製作實際在用的 CVC, 作到這一步就可以了, 把 private key 保管好, csr 送給 CableLabs, <a href="http://cablelabs.com/wp-content/uploads/2013/11/DCAA_DOCSIS.pdf">簽約</a>, 繳費 CableLabs 就會處理接下來的事情, 若是要做 Test CVC 就繼續往下做</p>

<p><strong>3. 製作 extension 欄位的設定檔 ext.txt</strong>
<figure class='code'><figcaption><span>ext.txt</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">extendedKeyUsage</span> <span class="o">=</span> <span class="s">critical,codeSigning</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><strong>4.用 Test DOCSIS Root Key 簽發憑證</strong></p>

<p><figure class='code'><figcaption><span>bash </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>openssl x509 -req -days <span class="m">3653</span> -in csr.pem -CA TEST_DOCSIS_CABLE_MODEM_ROOT_CA.PEM <span class="se">\</span>
</span><span class='line'>-CAkey TEST_DOCSIS_CABLE_MODEM_ROOT_CA_PrivateKey.PEM -CAcreateserial <span class="se">\</span>
</span><span class='line'>-extfile ext.txt -sha1 -out TEST_DOCSIS_MFR_CVC.crt
</span></code></pre></td></tr></table></div></figure></p>

<p>然後就能拿 TEST_DOCSIS_MFR_CVC.crt 和 TEST_DOCSIS_MFR_CVC_PRIVATEKEY.pem 去 sign image 了</p>

<h2 id="new-pki-docsis-31">New PKI (DOCSIS 3.1)</h2>

<p>製作 DOCSIS 3.1 的 CVC 方法和 3.0 的差不多, 設定檔和 CA 換一下就可以了</p>

<p><strong>1. 製作 csr_config.txt</strong></p>

<p><figure class='code'><figcaption><span>csr_config.txt</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="k">[ req ]</span>
</span><span class='line'><span class="na">default_keyfile</span> <span class="o">=</span> <span class="s">TEST_DOCSIS31_MFR_CVC_PRIVATEKEY.PEM</span>
</span><span class='line'><span class="na">default_md</span> <span class="o">=</span> <span class="s">sha256</span>
</span><span class='line'><span class="na">prompt</span> <span class="o">=</span> <span class="s">no</span>
</span><span class='line'><span class="na">string_mask</span> <span class="o">=</span> <span class="s">nombstr</span>
</span><span class='line'><span class="na">distinguished_name</span> <span class="o">=</span> <span class="s">req_DN&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="na">&lt;h1 id</span><span class="o">=</span><span class="s">&quot;certificate-distinguished-name-1&quot;&gt;Certificate Distinguished Name&lt;/h1&gt;</span>
</span><span class='line'><span class="err">&lt;p&gt;</span><span class="k">[req_DN]</span>
</span><span class='line'><span class="na">C</span> <span class="o">=</span> <span class="s">TW</span>
</span><span class='line'><span class="na">O</span> <span class="o">=</span> <span class="s">Jimmy Test</span>
</span><span class='line'><span class="na">CN</span> <span class="o">=</span> <span class="s">TEST Code Verification Certificate</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>3.1 的演算法變成 SHA-256</p>

<p><strong>2. 產生 CSR 和 private key</strong></p>

<p><figure class='code'><figcaption><span>bash </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>openssl req -newkey rsa:2048 -config csr_config.txt -out csr.pem -nodes
</span></code></pre></td></tr></table></div></figure></p>

<p>3.1 CVC RSA key length 變為 2048 bits</p>

<p><strong>3. 製作 extension 欄位的設定檔 ext.txt</strong></p>

<p><figure class='code'><figcaption><span>ext.txt</span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='ini'><span class='line'><span class="na">extendedKeyUsage</span><span class="o">=</span><span class="s">critical,codeSigning</span>
</span><span class='line'><span class="na">authorityKeyIdentifier</span><span class="o">=</span><span class="s">keyid,issuer</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>3.1 CVC 多了 authorityKeyIdentifier 這個 extension, authorityKeyIdentifier 的值會是 CVC CA 的 subjectKeyIdentifier<sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup></p>

<p><strong>4. 用 Test DOCSIS CVC CA Key 簽發憑證</strong></p>

<p><figure class='code'><figcaption><span>bash </span></figcaption>
<div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='bash'><span class='line'>openssl x509 -req -days <span class="m">3653</span> -in csr.pem -CA TEST_CABLELABS_CVC_CERTIFICATION_AUTHORITY_PEM.CRT <span class="se">\</span>
</span><span class='line'>-CAkey TEST_CABLELABS_CVC_CERTIFICATION_AUTHORITY_PRIVATEKEY.PEM -CAcreateserial -extfile ext.txt <span class="se">\</span>
</span><span class='line'>-sha256 -out TEST_DOCSIS31_MFR_CVC_PEM.CRT
</span></code></pre></td></tr></table></div></figure></p>

<p>3.1 CVC 的 chain 多了一張 CVC CA, 不再是直接由 Root 簽發, 製作 signed image 時除了 CVC 和 private key 之外也要把 CVC CA 包進去</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="https://www.openssl.org/docs/manmaster/apps/x509v3_config.html#Authority-Key-Identifier">OpenSSL x509v3 config</a> <a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
</feed>
